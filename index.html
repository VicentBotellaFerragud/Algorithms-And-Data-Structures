<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithms-And-Data-Structures</title>
    <link rel="stylesheet" href="style.css">
    <script src="script.js" defer></script>
    <script src="explanations.js" defer></script>
</head>

<body>
    <h1>Algorithms And Data Structures</h1>

    <div>
        <h3>Conditions</h3>
        <h4>Enter two values and click the "SORT ASC" button to sort them in ascending order:</h4>
        <input type="number" name="valueA" id="valueA">
        <input type="number" name="valueB" id="valueB">
        <button onclick="compareTwoValues(Number(valueA.value), Number(valueB.value))">SORT ASC</button>
        <span id="compareTwoValuesResult"></span>
        <br>
        <div id="conditionsExplanation" class="my-1"></div>
        <hr>
    </div>

    <div>
        <h3>Loops</h3>
        <h4>Press the space key and see if anything happens. Now press the "START" button and repeat
            the same process. Does anything different happen now?</h4>
        <button onclick="activateSpaceGame()">START</button>
        <button onclick="deactivateSpaceGame()">FINISH</button>
        <span id="hiddenMessageByDefault"></span>
        <br>
        <div id="loopsExplanation" class="my-1"></div>
        <hr>
    </div>

    <div>
        <h3>Running time of a function of n</h3>
        <h4>O(n):</h4>
        <h4>Enter a number from 1 to 10 to see what type of pizza corresponds to it and how many iterations the function
            had to do to find this pizza type:</h4>
        <input type="number" name="pizzaType" id="pizzaType" min="1" max="10">
        <button onclick="findAGivenPizza(Number(pizzaType.value))">FIND</button>
        <span id="iterationsCountResult1"></span>
        <br>
        <div id="oOfNExplanation" class="my-1"></div>
        <h4>O(nÂ²):</h4>
        <h4>Now click the "FIND DUPLICATES" button to see if there's any pizza type repeated on the pizza types list.
            How many iterations do you think the function has to do in this case to find out the answer? You'll see when
            you click the button.</h4>
        <button onclick="findDuplicatePizzaTypes()">FIND DUPLICATES</button>
        <span id="iterationsCountResult2"></span>
        <br>
        <div id="oOfNSquareExplanation" class="my-1"></div>
        <hr>
    </div>

    <div>
        <h3>Arrays</h3>
        <h4>What is an array?</h4>
        <span>An array is a collection of similar data elements stored at contiguous memory locations. It is the
            simplest data structure where each data element can be accessed directly by only using its index
            number.</span>
        <h4>Running times for an array of 10 elements:</h4>
        <ul>
            <li>When accessing elements: 1 --> O(1)</li>
            <li>When searching elements: 10 --> O(n)</li>
            <li>When inserting elements: 10 --> O(n)</li>
            <li>When deleting elements: 10 --> O(n)</li>
        </ul>
        <hr>
    </div>

    <div>
        <h3>Linked lists</h3>
        <h4>What is a linked list?</h4>
        <span>A linked list is a linear collection of data elements whose order is not given by their physical placement
            in memory. Instead, each element points to the next. It is a data structure consisting of a collection of
            nodes which together represent a sequence. In its most basic form, each node contains: data, and a reference
            (in other words, a link) to the next node in the sequence. This structure allows for efficient insertion or
            removal of elements from any position in the sequence during iteration.
        </span>
        <h4>Running times for a linked list of 10 elements:</h4>
        <ul>
            <li>When accessing elements: 10 --> O(n)</li>
            <li>When searching elements: 10 --> O(n)</li>
            <li>When inserting elements: 10 --> O(1)</li>
            <li>When deleting elements: 10 --> O(1)</li>
        </ul>
        <hr>
    </div>

    <div>
        <h3>Doubly linked lists</h3>
        <h4>What is a doubly linked list?</h4>
        <span>A doubly linked list is a complex type of linked list in which a node contains a pointer to the previous
            as well as the next node in the sequence. Therefore, in a doubly linked list, a node consists of three
            parts: node data, pointer to the next node in sequence (next pointer) and pointer to the previous node
            (previous pointer).
        </span>
        <h4>Running times for a doubly linked list of 10 elements:</h4>
        <ul>
            <li>When accessing elements: 10 --> O(n)</li>
            <li>When searching elements: 10 --> O(n)</li>
            <li>When inserting elements: 10 --> O(1)</li>
            <li>When deleting elements: 10 --> O(1)</li>
        </ul>
        <hr>
    </div>

    <div>
        <h3>Queues / Fifos</h3>
        <h4>What is a queue (also known as fifo)?</h4>
        <span>A queue is a collection of entities that are maintained in a sequence and can be modified by the addition
            of entities at one end of the sequence and the removal of entities from the other end of the sequence. By
            convention, the end of the sequence at which elements are added is called the back, tail, or rear of the
            queue, and the end at which elements are removed is called the head or front of the queue. This type of data
            structure follows the FIFO (First-In-First-Out) principle.</span>
        <h4>Running times for a queue of 10 elements:</h4>
        <ul>
            <li>When accessing elements: 10 --> O(n)</li>
            <li>When searching elements: 10 --> O(n)</li>
            <li>When inserting elements: 10 --> O(1)</li>
            <li>When deleting elements: 10 --> O(1)</li>
        </ul>
        <hr>
    </div>

    <div>
        <h3>Stacks / Lifos</h3>
        <h4>What is a stack (also known as lifo)?</h4>
        <span>A stack is a linear type of data structure that follows the LIFO (Last-In-First-Out) principle and allows
            insertion and deletion operations from one end of the stack data structure: the top.</span>
        <h4>Running times for a stack of 10 elements:</h4>
        <ul>
            <li>When accessing elements: 10 --> O(n)</li>
            <li>When searching elements: 10 --> O(n)</li>
            <li>When inserting elements: 10 --> O(1)</li>
            <li>When deleting elements: 10 --> O(1)</li>
        </ul>
        <hr>
    </div>

    <div>
        <h3>Sets</h3>
        <h4>What is a set?</h4>
        <span>A set is an abstract data type that stores an unordered collection of unique values.</span>
        <hr>
    </div>

    <div>
        <h3>Hash map</h3>
        <h4>What is a hash map?</h4>
        <span>A hash map is a data structure that implements an associative array or dictionary. It is an abstract data
            type that maps keys to values. A hash map uses a hash function to compute an index, also called a hash
            code, into an array of buckets or slots, from which the desired value can be found. During lookup, the key
            is hashed and the resulting hash indicates where the corresponding value is stored.</span>
        <h4>Running times for a hash map of 10 elements:</h4>
        <ul>
            <li>When accessing elements: not possible.</li>
            <li>When searching elements: on average 1 --> O(1) / worst case 10 --> O(n)</li>
            <li>When inserting elements: on average 1 --> O(1) / worst case 10 --> O(n)</li>
            <li>When deleting elements: on average 1 --> O(1) / worst case 10 --> O(n)</li>
        </ul>
        <hr>
    </div>

    <div>
        <h3>Binary search</h3>
        <h4>What is binary search?</h4>
        <span>Binary Search is a search algorithm for finding an element's position in a sorted list.</span>
        <h4>How does it work?</h4>
        <span>This search algorithm works on the principle of divide and conquer. Binary search looks for a specific
            item by comparing it with the middle element of a collection. If a match occurs, then the index of the
            middle element is returned. If the middle element is greater than the specific item, then the item is
            searched in the sub-array to the left of the middle element. Otherwise, the item is searched in the
            sub-array to the right of the middle element. This process continues on the sub-array as well until the
            specific item is found (or until the size of the subarray reduces to zero).</span>
        <h4>Example of binary search:</h4>
        <span>Consider the following list: {10, 20, 30, 40, 60, 110, 120, 130, 170}</span>
        <p>Enter in the input below "130".</p>
        <input type="number" name="binaySearch" id="binaySearch">
        <button onclick="binarySearch(sortedNumbers, Number(binaySearch.value))">FIND LIST INDEX OF THE PASSED-IN
            ELEMENT AND HOW MANY TIMES THE ALGORITHM HAD TO SPLIT THE LIST IN
            HALF</button>
        <span id="binarySearchResult"></span>
        <p>Now click on the button to the right of the input. Considering how the algorithm works, how many times should
            the algorithm split the list in half before finding the item "130"? Does your answer match the solution? Of
            course you can try the algorithm with other items, but keep in mind that if you enter in the input an item
            that does not belong to the list the resulting index will be "-1" (also remember that the first item on the
            list has index 0, not 1).</p>
        <p>On a list of n elements, binary search has a running time of O(log n).</p>
        <hr>
    </div>

    
    <div>
        <h3>Selection sort</h3>
        <h4>What is selection sort?</h4>
        <hr>
    </div>

</body>

</html>